<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tufts Sonic Anemometer – Long Duration Balloon Mission 2025</title>
    <link rel="stylesheet" href="/static/format.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.css">
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.6.0/socket.io.js"></script>
    <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
    <style>
        .graph-container {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }
        .graph {
            width: 45%;
            height: 250px;
            margin: 0 10px;
            position: relative; /* For positioning the modebar */
        }
        #renderCanvas {
            width: 100%;
            height: 300px;
            display: block;
            touch-action: none;
        }
        #title-section {
            text-align: center;
            margin: 20px 0;
        }
        #about-toggle-btn, .btn {
            background-color: #007BFF;
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            text-decoration: none; /* For the link */
            display: inline-block; /* Ensures consistent sizing */
            width: 200px; /* Fixed width for uniformity */
            text-align: center; /* Centers text in buttons */
        }
        #about-toggle-btn:hover, .btn:hover {
            background-color: #0056b3;
        }
        #about-section {
            margin-top: 20px;
        }
        /* Move Plotly modebar to the bottom */
        .modebar {
            top: auto !important;
            bottom: 0 !important;
            padding-bottom: 5px; /* Add some spacing from the bottom edge */
        }
        /* Add padding below the map */
        #map {
            margin-bottom: 20px; /* Space between map and graphs */
        }
        .button-container {
            display: flex;
            justify-content: center; /* Center buttons horizontally */
            gap: 20px; /* Space between buttons */
        }
    </style>
</head>
<body>
    <header>
        <div class="header-content">
            <h3>Flight Data Visualization</h3>
            <h6>Elias Bilal & Prof. Robert White, Tufts Mechanical Engineering</h6>
        </div>
        <nav>
            <ul class="nav_links">
                <li><a href="https://sites.tufts.edu/senselab/research/#anemometer">MSS Lab Site</a></li>
            </ul>
        </nav>
    </header>
    <div class="button-container">
        <div id="title-section">
            <button id="about-toggle-btn">Project Summary</button>
        </div>
        <div id="download-section">
            <a href="/download-history" class="btn" download>Download History as CSV</a>
        </div>
    </div>

    <div id="map" style="height: 500px; width: 100%;"></div>

    <!-- Row 1: Altitude and Temperature -->
    <div class="graph-container">
        <div id="altitude-graph" class="graph"></div>
        <div id="temperature-graph" class="graph"></div>
    </div>

    <!-- Row 2: Orientation and Pressure -->
    <div class="graph-container">
        <div id="orientation-graph" class="graph"></div>
        <div id="pressure-graph" class="graph"></div>
    </div>

    <!-- Row 3: Average Wind and Std Dev Wind -->
    <div class="graph-container">
        <div id="average-wind-graph" class="graph"></div>
        <div id="stddev-wind-graph" class="graph"></div>
    </div>

    <!-- Row 4: Peak Wind -->
    <div class="graph-container">
        <div id="peak-wind-graph" class="graph"></div>
    </div>

    <!-- <canvas id="renderCanvas"></canvas> --> <!-- Commented out as requested -->

    <div style="text-align: center;">
        <div style="margin-top: 10px; font-size: 16px;">
            Latitude: <span id="lat">0</span>
        </div>
        <div style="margin-top: 10px; font-size: 16px;">
            Longitude: <span id="lon">0</span>
        </div>
        <div style="margin-top: 10px; font-size: 16px;">
            Temperature: <span id="temp">0</span> °C
        </div>
        <div style="margin-top: 10px; font-size: 16px;">
            Pressure: <span id="pressure">0</span> mbar
        </div>
        <div id="about-section">
            <h6 style="text-align: center">Project Summary</h6>
            <p style="text-align: center">
                The Tufts high altitude sonic anemometer [1,2] is flying on a long duration high altitude balloon mission out of Wanaka, New Zealand, courtesy of NASA and the Columbia Scientific Ballooning Facility. As far as we are aware, this is the first ever long duration flight of a stratospheric sonic anemometer. The instrument will monitor vector (3D) relative winds at the gondola with an update rate of approximately 3 x 3D measurements per second. The system also includes pressure and temperature sensors, a 9DOF IMU for geospatial orientation, and a GPS receiver. All the data is logged internally and will be available with the high update rate (3 Hz) recording for the entire mission when the gondola is recovered. However, there is some risk that the data could be lost if recovery is not possible, and the data will not be available for some time during transit. In addition to the logged data, Iridium messages are sent over the Iridium network once every 20 minutes. These messages contain mean wind, the standard deviation of wind, and the peak wind in the last 20 minute interval (all as 3D vectors), in addition to pressure, temperature, altitude, location, and orientation information.</p> <p> The goals of this site are to monitor flight data without needing to wait for SD card retrieval and to create a platform to share the recorded high altitude wind anemometry data with the global scientific community. This Pyscript Webhook site receives hex encoded messages sent from a mission balloon mounted Artemis Global Tracker over the Iridium Network through RockBlock. The backend Python file then parses that message and updates the map, graphs and model to display the data live on the front end HTML file. This web service is hosted on Render and message data is saved onto a persistent disk. The full system (sensor head, electronics, signal processing, communications, and web services) were built by students in Prof. Robert White’s group at Tufts University (<a href="https://sites.tufts.edu/senselab/">https://sites.tufts.edu/senselab/</a>). Students involved include Elias Bilal (web system programming, mechanical fabrication), Rishabh Chaudhary (transducers, acoustics, and signal processing), Tim Cheng (system electronics and signal processing), Julia Huckaby (mechanical design), and Zarina Kosherbayeva (mechanical design and fabrication).<br><p>
                <p style="text-align: center">[1] Cheng, Tim J., et al. "Test Flight of a Stratospheric Sonic Anemometer Prototype." <i>Journal of Atmospheric and Oceanic Technology</i> 41.12 (2024): 1139-1149. <a href="https://journals.ametsoc.org/view/journals/atot/41/12/JTECH-D-24-0010.1.xml">https://journals.ametsoc.org/view/journals/atot/41/12/JTECH-D-24-0010.1.xml</a><br>
                [2] White, Robert D., et al. "Flow Testing of a Digital Sonic Anemometer for Martian and Stratospheric Environments." <i>AIAA AVIATION FORUM AND ASCEND 2024</i>. <a href="https://arc.aiaa.org/doi/abs/10.2514/6.2024-3933">https://arc.aiaa.org/doi/abs/10.2514/6.2024-3933</a>
            </p>
        </div>
        <div>
            <h2>Latest Message:</h2>
            <p id="latest-message">No messages yet.</p>
        </div>
        <div>
            <h2>Message History:</h2>
            <ul id="message-history" style="display: inline-block; text-align: left;"></ul>
        </div>
    </div>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

    <script>
        const BASE_URL = "https://ultrasonic-anemometer.onrender.com";

        const map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

        const flightPath = L.polyline([], { color: 'red' }).addTo(map);
        const marker = L.marker([0, 0]).addTo(map);
        let hasUserInteracted = false;

        map.on('zoomstart', () => { hasUserInteracted = true; });

        const updateMap = (historyData) => {
            flightPath.setLatLngs([]);
            historyData.forEach(data => {
                if (data.latitude && data.longitude) {
                    const latLng = [data.latitude, data.longitude];
                    flightPath.addLatLng(latLng);
                }
            });
            const latest = historyData[historyData.length - 1];
            if (latest && latest.latitude && latest.longitude) {
                marker.setLatLng([latest.latitude, latest.longitude]);
                document.getElementById('lat').textContent = latest.latitude.toFixed(6);
                document.getElementById('lon').textContent = latest.longitude.toFixed(6);
                if (!hasUserInteracted && flightPath.getLatLngs().length > 1) {
                    map.fitBounds(flightPath.getBounds());
                }
            }
        };

        const config = {
            displayModeBar: true, // Always show the modebar
            modeBarButtonsToRemove: ['toImage', 'sendDataToCloud'], // Remove unnecessary buttons
            displaylogo: false // Hide Plotly logo
        };

        const updateAltitudeGraph = (historyData) => {
            const timestamps = historyData.map(data => data.sent_time).filter(t => t);
            const altitudes = historyData.map(data => data.altitude).filter(a => a !== undefined);

            if (timestamps.length === 0 || altitudes.length === 0) return;

            const graphData = [{
                x: timestamps,
                y: altitudes,
                type: 'scatter',
                mode: 'lines+markers',
                line: { color: 'blue' },
                name: "Altitude (m)"
            }];

            const layout = {
                title: { text: "Altitude", standoff: 20 },
                xaxis: { title: "Time (s)" },
                yaxis: { title: "Altitude (m)" },
                margin: { t: 60, b: 40, l: 40, r: 20 },
                height: 250
            };

            Plotly.react('altitude-graph', graphData, layout, config);
        };

        const updateTemperatureGraph = (historyData) => {
            const timestamps = historyData.map(data => data.sent_time).filter(t => t);
            const ttip = historyData.map(data => data.temperature_tctip_c).filter(t => t !== undefined);
            const tcj = historyData.map(data => data.temperature_cj_c).filter(t => t !== undefined);
            const tpht = historyData.map(data => data.temperature_pht_c).filter(t => t !== undefined);

            if (timestamps.length === 0) return;

            const tempGraphData = [
                { x: timestamps, y: ttip, type: 'scatter', mode: 'lines+markers', name: 'Ttip (°C)', line: { color: 'red' } },
                { x: timestamps, y: tcj, type: 'scatter', mode: 'lines+markers', name: 'Tcj (°C)', line: { color: 'orange' } },
                { x: timestamps, y: tpht, type: 'scatter', mode: 'lines+markers', name: 'Tpht (°C)', line: { color: 'yellow' } }
            ];

            const layout = {
                title: { text: "Temperature", standoff: 20 },
                xaxis: { title: "Time (s)" },
                yaxis: { title: "Temperature (°C)" },
                margin: { t: 60, b: 40, l: 40, r: 20 },
                height: 250
            };

            Plotly.react('temperature-graph', tempGraphData, layout, config);
            const latest = historyData[historyData.length - 1];
            if (latest) {
                if (latest.temperature_cj_c !== undefined) {
                    document.getElementById("temp").textContent = latest.temperature_cj_c.toFixed(1);
                }
                if (latest.pressure_mbar !== undefined) {
                    document.getElementById("pressure").textContent = latest.pressure_mbar.toFixed(1);
                }
            }
        };

        const updateOrientationGraph = (historyData) => {
            const timestamps = historyData.map(data => data.sent_time).filter(t => t);
            const pitch = historyData.map(data => data.pitch_deg).filter(p => p !== undefined);
            const roll = historyData.map(data => data.roll_deg).filter(r => r !== undefined);
            const yaw = historyData.map(data => data.yaw_deg).filter(y => y !== undefined);

            if (timestamps.length === 0) return;

            const graphData = [
                { x: timestamps, y: pitch, type: 'scatter', mode: 'lines+markers', name: 'Pitch (°)', line: { color: 'blue' } },
                { x: timestamps, y: roll, type: 'scatter', mode: 'lines+markers', name: 'Roll (°)', line: { color: 'green' } },
                { x: timestamps, y: yaw, type: 'scatter', mode: 'lines+markers', name: 'Yaw (°)', line: { color: 'purple' } }
            ];

            const layout = {
                title: { text: "Orientation", standoff: 20 },
                xaxis: { title: "Time (s)" },
                yaxis: { title: "Degrees" },
                margin: { t: 60, b: 40, l: 40, r: 20 },
                height: 250
            };

            Plotly.react('orientation-graph', graphData, layout, config);
        };

        const updatePressureGraph = (historyData) => {
            const timestamps = historyData.map(data => data.sent_time).filter(t => t);
            const pressures = historyData.map(data => data.pressure_mbar).filter(p => p !== undefined);

            if (timestamps.length === 0 || pressures.length === 0) return;

            const graphData = [{
                x: timestamps,
                y: pressures,
                type: 'scatter',
                mode: 'lines+markers',
                line: { color: 'orange' },
                name: "Pressure (mbar)"
            }];

            const layout = {
                title: { text: "Pressure", standoff: 20 },
                xaxis: { title: "Time (s)" },
                yaxis: { title: "Pressure (mbar)" },
                margin: { t: 60, b: 40, l: 40, r: 20 },
                height: 250
            };

            Plotly.react('pressure-graph', graphData, layout, config);
        };

        const updateAverageWindGraph = (historyData) => {
            const timestamps = historyData.map(data => data.sent_time).filter(t => t);
            const vavg1 = historyData.map(data => data.vavg_1_mps).filter(v => v !== undefined);
            const vavg2 = historyData.map(data => data.vavg_2_mps).filter(v => v !== undefined);
            const vavg3 = historyData.map(data => data.vavg_3_mps).filter(v => v !== undefined);

            if (timestamps.length === 0) return;

            const graphData = [
                { x: timestamps, y: vavg1, type: 'scatter', mode: 'lines+markers', name: 'Vavg 1 (m/s)', line: { color: 'red' } },
                { x: timestamps, y: vavg2, type: 'scatter', mode: 'lines+markers', name: 'Vavg 2 (m/s)', line: { color: 'green' } },
                { x: timestamps, y: vavg3, type: 'scatter', mode: 'lines+markers', name: 'Vavg 3 (m/s)', line: { color: 'blue' } }
            ];

            const layout = {
                title: { text: "Average Wind", standoff: 20 },
                xaxis: { title: "Time (s)" },
                yaxis: { title: "Velocity (m/s)" },
                margin: { t: 60, b: 40, l: 40, r: 20 },
                height: 250
            };

            Plotly.react('average-wind-graph', graphData, layout, config);
        };

        const updateStdDevWindGraph = (historyData) => {
            const timestamps = historyData.map(data => data.sent_time).filter(t => t);
            const vstd1 = historyData.map(data => data.vstd_1_mps).filter(v => v !== undefined);
            const vstd2 = historyData.map(data => data.vstd_2_mps).filter(v => v !== undefined);
            const vstd3 = historyData.map(data => data.vstd_3_mps).filter(v => v !== undefined);

            if (timestamps.length === 0) return;

            const graphData = [
                { x: timestamps, y: vstd1, type: 'scatter', mode: 'lines+markers', name: 'Vstd 1 (m/s)', line: { color: 'red' } },
                { x: timestamps, y: vstd2, type: 'scatter', mode: 'lines+markers', name: 'Vstd 2 (m/s)', line: { color: 'green' } },
                { x: timestamps, y: vstd3, type: 'scatter', mode: 'lines+markers', name: 'Vstd 3 (m/s)', line: { color: 'blue' } }
            ];

            const layout = {
                title: { text: "Std Dev of Wind", standoff: 20 },
                xaxis: { title: "Time (s)" },
                yaxis: { title: "Std Dev (m/s)" },
                margin: { t: 60, b: 40, l: 40, r: 20 },
                height: 250
            };

            Plotly.react('stddev-wind-graph', graphData, layout, config);
        };

        const updatePeakWindGraph = (historyData) => {
            const timestamps = historyData.map(data => data.sent_time).filter(t => t);
            const vpk1 = historyData.map(data => data.vpk_1_mps).filter(v => v !== undefined);
            const vpk2 = historyData.map(data => data.vpk_2_mps).filter(v => v !== undefined);
            const vpk3 = historyData.map(data => data.vpk_3_mps).filter(v => v !== undefined);

            if (timestamps.length === 0) return;

            const graphData = [
                { x: timestamps, y: vpk1, type: 'scatter', mode: 'lines+markers', name: 'Vpk 1 (m/s)', line: { color: 'red' } },
                { x: timestamps, y: vpk2, type: 'scatter', mode: 'lines+markers', name: 'Vpk 2 (m/s)', line: { color: 'green' } },
                { x: timestamps, y: vpk3, type: 'scatter', mode: 'lines+markers', name: 'Vpk 3 (m/s)', line: { color: 'blue' } }
            ];

            const layout = {
                title: { text: "Peak Wind", standoff: 20 },
                xaxis: { title: "Time (s)" },
                yaxis: { title: "Velocity (m/s)" },
                margin: { t: 60, b: 40, l: 40, r: 20 },
                height: 250
            };

            Plotly.react('peak-wind-graph', graphData, layout, config);
        };

        const fetchAndUpdateAll = async () => {
            try {
                const response = await fetch(`${BASE_URL}/history`);
                if (!response.ok) {
                    console.error(`Fetch failed with status: ${response.status}`);
                    return;
                }
                const historyData = await response.json();
                if (historyData.length > 0) {
                    updateMap(historyData);
                    updateAltitudeGraph(historyData);
                    updateTemperatureGraph(historyData);
                    updateOrientationGraph(historyData);
                    updatePressureGraph(historyData);
                    updateAverageWindGraph(historyData);
                    updateStdDevWindGraph(historyData);
                    updatePeakWindGraph(historyData);
                    // updateWindVectors(historyData); // Commented out as part of 3D animation removal
                }
            } catch (error) {
                console.error("Error fetching history:", error);
            }
        };

        const fetchHistory = async () => {
            await fetchAndUpdateAll();
        };

        window.onload = async () => {
            await fetchHistory();
            setInterval(fetchAndUpdateAll, 1000);

            // Scroll to About section when button is clicked
            const aboutButton = document.getElementById('about-toggle-btn');
            const aboutSection = document.getElementById('about-section');
            aboutButton.addEventListener('click', () => {
                aboutSection.scrollIntoView({ behavior: 'smooth' });
            });
        };

        document.addEventListener("DOMContentLoaded", function () {
            fetchMessageHistory();
            fetchLatestMessage();
        });

        async function fetchLatestMessage() {
            try {
                const response = await fetch(`${BASE_URL}/live-data`);
                if (!response.ok) return;
                const data = await response.json();
                if (data.message) {
                    document.getElementById('latest-message').textContent = `Message: ${data.message}`;
                } else {
                    document.getElementById('latest-message').textContent = `Received structured data at ${data.received_time}`;
                }
            } catch (error) {
                console.error("Error fetching latest message:", error);
            }
        }

        async function fetchMessageHistory() {
            try {
                const response = await fetch(`${BASE_URL}/message-history`);
                if (!response.ok) return;
                const historyData = await response.json();

                const historyList = document.getElementById('message-history');
                historyList.innerHTML = '';
                historyData.forEach((msg) => {
                    const listItem = document.createElement('li');
                    listItem.textContent = `(${msg.received_time}) Msg: ${msg.message} | Lat: ${msg.latitude}, Lon: ${msg.longitude}`;
                    historyList.appendChild(listItem);
                });
            } catch (error) {
                console.error("Error fetching message history:", error);
            }
        }

        /* Commented out 3D model and axis animation code below */
        /*
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);

        const createScene = () => {
            const scene = new BABYLON.Scene(engine);
            const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 4, 4, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);

            let satellite;
            BABYLON.SceneLoader.Append("./static/models/", "AnemometerAssembly.gltf", scene, () => {
                satellite = scene.meshes[0];
                satellite.position = BABYLON.Vector3.Zero();
                satellite.scaling = new BABYLON.Vector3(0.5, 0.5, 0.5);
                console.log("Anemometer loaded and centered");
            });

            const createArrow = (name, color, initialPosition) => {
                const arrow = BABYLON.MeshBuilder.CreateCylinder(name, {
                    height: 0.3,
                    diameterTop: 0,
                    diameterBottom: 0.03
                }, scene);
                const arrowMaterial = new BABYLON.StandardMaterial(name + "Material", scene);
                arrowMaterial.diffuseColor = color;
                arrow.material = arrowMaterial;
                arrow.position = initialPosition;
                return arrow;
            };

            const windArrows = {
                x: createArrow("windX", new BABYLON.Color3(1, 0, 0), new BABYLON.Vector3(1, 0, 0)),
                y: createArrow("windY", new BABYLON.Color3(0, 1, 0), new BABYLON.Vector3(0, 1, 0)),
                z: createArrow("windZ", new BABYLON.Color3(0, 0, 1), new BABYLON.Vector3(0, 0, 1))
            };

            return { scene, windArrows };
        };

        const { scene, windArrows } = createScene();

        const updateWindVectors = (historyData) => {
            const latest = historyData[historyData.length - 1];
            if (!latest) return;

            const vX = latest.vavg_1_mps || 0;
            const vY = latest.vavg_2_mps || 0;
            const vZ = latest.vavg_3_mps || 0;

            windArrows.x.scaling.y = Math.abs(vX) * 0.5;
            windArrows.x.rotation = new BABYLON.Vector3(0, 0, vX >= 0 ? 0 : Math.PI);
            windArrows.x.position = new BABYLON.Vector3(vX >= 0 ? 1 : -1, 0, 0);

            windArrows.y.scaling.y = Math.abs(vY) * 0.5;
            windArrows.y.rotation = new BABYLON.Vector3(vY >= 0 ? -Math.PI / 2 : Math.PI / 2, 0, 0);
            windArrows.y.position = new BABYLON.Vector3(0, vY >= 0 ? 1 : -1, 0);

            windArrows.z.scaling.y = Math.abs(vZ) * 0.5;
            windArrows.z.rotation = new BABYLON.Vector3(0, vZ >= 0 ? Math.PI / 2 : -Math.PI / 2, 0);
            windArrows.z.position = new BABYLON.Vector3(0, 0, vZ >= 0 ? 1 : -1);

            console.log(`Wind vectors: vX=${vX}, vY=${vY}, vZ=${vZ}`);
        };

        engine.runRenderLoop(() => {
            scene.render();
        });

        window.addEventListener("resize", () => {
            engine.resize();
        });
        */
    </script>
</body>
</html>
